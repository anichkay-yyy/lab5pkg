# Документация: приложение для отсечения отрезков и выпуклых многоугольников (вариант 13)

## Назначение

Приложение визуализирует работу алгоритмов отсечения:

- Коэн–Сазерленд для отсечения отрезков прямоугольным окном.
- Сазерленд–Ходжман для отсечения выпуклого многоугольника выпуклым клипером.

Графический интерфейс на `tkinter` с двумя вкладками: «Отрезки» и «Многоугольник». Встраиваемый график построен на `matplotlib`: отображаются оси координат, окно/клипер, исходные примитивы и результат отсечения разными цветами.

## Требования

- Python 3.8+
- Библиотеки: `matplotlib` (для некоторых дистрибутивов Linux может потребоваться `python3-tk`)

Установка зависимостей:
```bash
pip install matplotlib
```

## Форматы входных файлов

### Отрезки + прямоугольное окно

```
n
x1 y1 x2 y2
...
xmin ymin xmax ymax
```

- `n` — количество отрезков.
- Каждая строка далее: координаты концов отрезка.
- Последняя строка: границы прямоугольного окна.

### Выпуклый многоугольник (исходный и клипер)

```
m
x1 y1
x2 y2
...
xm ym
```

- `m` — количество вершин.
- Вершины задаются в порядке обхода против часовой стрелки (выпуклый).

Оба файла (исходный многоугольник и клипер) имеют одинаковый формат.

## Алгоритмы

### Коэн–Сазерленд (отрезок–прямоугольник)

Суть:
- Пространство делится на 9 регионов. Каждой точке присваивается 4-битный код (outcode) по положению относительно окна: LEFT, RIGHT, TOP, BOTTOM.
- Битовое И кодов концов:
  - Если оба кода равны 0 — отрезок целиком внутри (принимаем).
  - Если пересечение кодов не 0 — отрезок целиком вне (отбрасываем).
  - Иначе — вычисляем пересечение с соответствующей стороной окна по активному биту, заменяем внешний конец, повторяем.

Плюсы: простая реализация, быстрые тривиальные случаи. Минусы: возможны повторные вычисления пересечений.

### Сазерленд–Ходжман (многоугольник–выпуклый клипер)

Суть:
- Итерируем по граням клипера, последовательно «режем» исходный многоугольник каждой гранью.
- Для каждой грани берём текущий список вершин и формируем новый, проходя пары соседних вершин $P \to Q$:
  - Если $Q$ внутри — добавляем пересечение (если $P$ снаружи) и $Q$.
  - Если $Q$ снаружи, но $P$ внутри — добавляем пересечение.
  - Если оба снаружи — ничего не добавляем.
- «Внутри» определяется проверкой знака векторного произведения: $((b.x - a.x)(p.y - a.y) - (b.y - a.y)(p.x - a.x)) \ge 0$ для ориентированного ребра $A \to B$ (при обходе против часовой стрелки внутренняя сторона слева).

Плюсы: простота, предсказуемость для выпуклых клиперов. Минусы: требует выпуклости клипера.

## Интерфейс

Главное окно содержит вкладки:

- **Отрезки**
  - Кнопка «Открыть файл отрезков» — загрузка файла формата «отрезки + прямоугольное окно».
  - Кнопка «Отсечь» — запускает Коэн–Сазерленд для всех отрезков.
  - Поле отображает путь к загруженному файлу.
  - График: окно — синим, исходные отрезки — серым пунктиром, видимые части — красным.

- **Многоугольник**
  - Кнопки «Исходный многоугольник» и «Клипер (окно)» — загрузка двух файлов с выпуклыми многоугольниками.
  - Кнопка «Отсечь» — запускает Сазерленд–Ходжман.
  - Поля отображают пути к файлам.
  - График: клипер — синим, исходный многоугольник — серым пунктиром, отсечённый — зелёным (контур + заливка).

Оси координат подсвечены серым, включена сетка.

## Порядок работы

1. Установите зависимости: `pip install matplotlib`.
2. Запустите приложение:
   ```bash
   python clip_app.py
   ```
3. Вкладка «Отрезки»:
   - Нажмите «Открыть файл отрезков» и выберите файл формата «отрезки + окно».
   - Нажмите «Отсечь». Результат появится на графике.
4. Вкладка «Многоугольник»:
   - Нажмите «Исходный многоугольник» и выберите файл с вершинами исходного выпуклого многоугольника.
   - Нажмите «Клипер (окно)» и выберите файл с вершинами выпуклого клипера.
   - Нажмите «Отсечь». Результат появится на графике.

## Подробности реализации

- Структуры данных: `Point`, `Segment`, `Rect` (`dataclass`).
- Отрисовка: `matplotlib` на встроенном холсте `FigureCanvasTkAgg`.
- Координированные оси: `axhline`/`axvline` с малой толщиной и светлым цветом.
- Легенда формируется автоматически по цветам/лейблам.
- Проверка выпуклости клипера не выполняется: предполагается корректный вход (выпуклый, обход против часовой стрелки).

## Ограничения и замечания

- Коэн–Сазерленд работает только с прямоугольным окном.
- Сазерленд–Ходжман корректен при выпуклом клипере и корректном порядке обхода.
- Точность пересечений зависит от вычислений с плавающей точкой; при почти параллельных рёбрах возможны численные артефакты.
- Нет автоматической нормализации масштабов: график подгоняет область данных, оси равные по масштабу.

## Форматы сообщений и ошибок

- При ошибке чтения файла — `messagebox.showerror` с текстом исключения.
- При отсутствии данных перед запуском алгоритма — предупреждение `showwarning`.
- При успешной загрузке — `showinfo` с кратким резюме (количество примитивов, границы окна).

## Быстрый пример входных данных

Отрезки и окно:
```
3
0 0 10 10
-5 5 5 -5
12 0 12 10
0 0 8 8
```

Многоугольник (клипер):
```
4
0 0
8 0
8 8
0 8
```

Исходный многоугольник:
```
5
-2 2
4 10
12 6
10 -2
2 -2
```

## Структура файла `clip_app.py`

- Алгоритмы: `cohen_sutherland_clip`, `sutherland_hodgman_clip_polygon`.
- Парсеры: `read_segments_rect` (отрезки + окно), `read_polygon` (многоугольники).
- Рисование: `plot_segments`, `plot_polygon`.
- GUI: класс `ClipApp` (вкладки, кнопки, обработчики загрузки и запуска, канвасы для графиков).
- Точка входа: `main()`, запускает цикл `app.mainloop()`.

## Как это работает «в одном предложении»

- Коэн–Сазерленд: на основе битовых кодов концов отрезка быстро решает, целиком ли он внутри/вне окна, или постепенно сдвигает внешний конец к ближайшей границе до полной классификации.
- Сазерленд–Ходжман: последовательно «режет» исходный многоугольник по каждой грани выпуклого клипера, добавляя/заменяя вершины пересечениями, пока не получит итоговый отсечённый многоугольник.
